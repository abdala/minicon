#!/bin/bash
#
# minicon - Minimization of filesystems for containers
# https://github.com/grycap/minicon
#
# Copyright (C) GRyCAP - I3M - UPV 
# Developed by Carlos A. caralla@upv.es
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

function usage() {
  cat <<EOF
minicon aims at reducing the footprint of the filesystem for the container, just adding those 
  files that are needed. That means that the other files in the original container are removed.

$0 <option> <executables to analyze, files or folders to include>

  --rootfs | -r       Create the filesystem in a specific folder.
  --tar-file | -t     Generate a tar file that contains the resulting filesystem. This is
                      ideal to import it into docker using the command "docker import". If 
                      not specified the --rootfs parameter, minicon will use a temporary 
                      folder.
  --exclude | -e <F>  Exclude all paths that begin with 'F' (it accepts texts for regular expressions)
  --ldconfig | -l     Generate a /etc/ldconfig.so file, adjusted to the new filesystem. 
                      It is suggested to always use this flag, to set the proper path to the
                      libraries included in the new filesystem.
  --plugin            Activates some plugins and sets the options for them. The syntax is
                      --plugin=<plugin name>:<parameter>=<value>:<parameter>=<value>...
  --plugin-all        Activates all the available plugins, using their default options.
  --logfile | -g <F>  Outputs the information in file F instead of stdout and stderr
  --quiet | -q        Makes the tasks silently
  --verbose | -v      Shows more information about the procedure.
  --debug             Shows a lot more information about the procedure.
  --help | -h         Shows this help and exits.

  Examples:
    # The next execution will try to execute the application bash for 3 seconds 
    # (the default value), but will exclude any file used by the application that 
    # is found either in /dev or /proc

    $ ./minicon -t tarfile --plugin=strace --exclude /dev --exclude /proc bash

    # The next execution will create a minimal container filesystem that only contains
    # bash, ls and mkdir. The result can be imported in Docker using the command
    # (e.g.) docker import minicont.tar test:mini
    $ docker run --rm --plugin-all -it -v \$PWD:/tmp/minicon \\
      ubuntu:latest /tmp/minicon/minicon -l -t minicont.tar bash ls mkdir
EOF
}

# Checking dependencies
function remove_from_plugins() {
  local P="$1"
  local PP=

  while [ "$PP" != "$PLUGINS_ACTIVATED" ]; do
    PP="$PLUGINS_ACTIVATED"
    PLUGINS_ACTIVATED="$(echo "$PLUGINS_ACTIVATED" | sed "s/\(^\|,\)\($P\(\|:[^,]*\)\)\(,\|$\)/\1\4/g")"
  done
}

function verify_dependencies() {
  if ! strace -V > /dev/null 2> /dev/null; then
    remove_from_plugins "strace"
    p_warning "disabling strace plugin because strace command is not available"
  fi
  if ! file --version > /dev/null 2> /dev/null; then
    remove_from_plugins "scripts"
    p_warning "disabling scripts plugin because file command is not available"
  fi
  if [ "$TARFILE" != "" ]; then
    if ! tar --version > /dev/null 2> /dev/null; then
      finalize 1 "tar command is needed to create tar files"
    fi
  fi
  if ! ldd --version > /dev/null 2> /dev/null; then
    finalize 1 "ldd command is needed for scripts plugin"
  fi
}

# Functions to output information depending on the configuration
function p_errfile() {
  if [ "$LOGFILE" == "" ]; then
    echo "$@" >&2
  else
    touch -f "$LOGFILE"
    if [ $? -eq 0 ]; then
      echo "$@" >> "$LOGFILE"
    fi
  fi
}

function p_error() {
  local O_STR="[ERROR] $LOGGER $(date +%Y.%m.%d-%X) $@"
  p_errfile "$O_STR"
}

function p_warning() {
  local O_STR="[WARNING] $LOGGER $(date +%Y.%m.%d-%X) $@"
  p_errfile "$O_STR"
}

function p_info() {
  local L
  if [ "$VERBOSE" == "true" ]; then
    local TS="$(date +%Y.%m.%d-%X)"
    while read L; do
      p_errfile "[INFO] $LOGGER $TS $@"
    done <<< "$@"
  fi
}

function p_out() {
  if [ "$QUIET" != "true" ]; then
    while read L; do
      echo "$@"
    done <<< "$@"
  fi
}

function p_debug() {
  local L
  if [ "$DEBUG" == "true" ]; then
    local TS="$(date +%Y.%m.%d-%X)"
    while read L; do
      p_errfile "[DEBUG] $LOGGER $TS $L"
    done <<< "$@"
  fi
}

function set_logger() {
  if [ "$1" != "" ]; then
    LOGGER="[$1]"
  else
    LOGGER=
  fi
}

function tempfile {
  # Creates a unique temporary file
  RES=$(/bin/tempfile 2> /dev/null)
  if [ $? -ne 0 ]; then
    RES=$(mktemp 2> /dev/null)
    while [ $? -ne 0 ]; do
      RES=/tmp/ftemp_${RANDOM}_$(date +%s)
      touch $RES
    done
  fi
  echo $RES
}

function tempdir() {
  # Creates a unique temporary folder
  local RES
  RES=$(/bin/tempfile 2> /dev/null)
  if [ $? -ne 0 ]; then
    RES=$(mktemp -d 2> /dev/null)
    while [ $? -ne 0 ]; do
      RES=/tmp/ftemp_${RANDOM}_$(date +%s)
      mkdir -p $RES
    done
  else
    rm -f "$RES" && mkdir -p "$RES"
  fi
  echo $RES
}

function finalize() {
  # Finalizes the execution of the this script and shows an error (if provided)
  local ERR=$1
  shift
  local COMMENT=$@
  [ "$ERR" == "" ] && ERR=0
  [ "$COMMENT" != "" ] && p_error "$COMMENT"
  if [ "$KEEPTEMPORARY" != "true" ]; then
    p_debug removing temporary folder "$TMPDIR"
    rm -rf "$TMPDIR"
  fi  
  exit $ERR
}

# Reads a configuration file and set its variables (removes comments, blank lines, trailing spaces, etc. and
# then reads KEY=VALUE settings)
function readconf() {
  local _CONF_FILE=$1
  local _CURRENT_SECTION
  local _TXT_CONF
  local _CURRENT_KEY _CURRENT_VALUE

  # If the config file does not exist return failure
  if [ ! -e "$_CONF_FILE" ]; then
    return 1
  fi

  # First we read the config file
  _TXT_CONF="$(cat "$_CONF_FILE" | sed 's/#.*//g' | sed 's/^[ \t]*//g' | sed 's/[ \t]*$//g' | sed '/^$/d')"

  # Let's read the lines
  while read L; do
    if [[ "$L" =~ ^\[.*\]$ ]]; then
      # If we are reading a section, let's see if it is applicable to us
      _CURRENT_SECTION="${L:1:-1}"
    else
      IFS='=' read _CURRENT_KEY _CURRENT_VALUE <<< "$L"
      _CURRENT_VALUE="$(echo "$_CURRENT_VALUE" | envsubst)"
      read -d '\0' "$_CURRENT_KEY" <<< "${_CURRENT_VALUE}"
    fi
  done <<< "$_TXT_CONF"
  return 0
}

function copy() {
  # copies one file (or folder) to the same destination in the root filesystem
  # - it does not overwrite contents
  local SRC="$1"
  local n EP

  for ((n=0;n<${#EXCLUDED_PATHS[@]};n++)); do
    EP="${EXCLUDED_PATHS[$n]}"
    if [[ "$SRC" =~ ^$EP ]]; then
      p_warning "excluding ${SRC} because it matches pattern ${EP}"
      return 0
    fi
  done

  if [ "$SRC" == "." -o "$SRC" == ".." ]; then
    p_warning "cowardly refusing to copy folder $SRC"
    return
  fi

  local DST
  if [ "$VERBOSE" == "true" ]; then
    p_info "  processing $SRC... "
  fi
  if [ ! -e "$SRC" ]; then
    p_error 1 "failed to read $SRC"
  fi
  local SRCDIR="$(dirname "$SRC")"
  DST="$ROOTFS/$SRCDIR"
  mkdir -p "$DST"
  p_debug "  copying $SRC to $DST"
  p_out "$SRC"
  if [ -d "$SRC" ]; then
    cp -n -r "$SRC" "$DST"
  else
    cp -n "$SRC" "$DST"
  fi
}

# Credits fot this function go to https://stackoverflow.com/a/18898782
# Return relative path from canonical absolute dir path $1 to canonical
# absolute dir path $2 ($1 and/or $2 may end with one or no "/").
# Does only need POSIX shell builtins (no external command)
function relPath () {
    local common path up
    common=${1%/} path=${2%/}/
    while test "${path#"$common"/}" = "$path"; do
        common=${common%/*} up=../$up
    done
    path=$up${path#"$common"/}; path=${path%/}; printf %s "${path:-.}"
}

function is_plugin_active() {
  # Checks whether a plugin is activated or not
  if [[ "$PLUGINS_ACTIVATED" =~ (^|,)$1(|:[^,]+)(,|$) ]]; then
    return 0
  fi  
  return 1
}

function plugin_parameter() {
  # Gets the value of a parameter passed to a plugin
  #   the format is: <plugin>:<param1>=<value1>:<param2>=<value2>...
  local PLUGIN="$1"
  local PARAMETER="$2"
  local PARAMS PP PP2 K V

  while read -d ',' PP; do
    if [[ "$PP" =~ ^$PLUGIN\: ]]; then
      PARAMS="${PP:$((${#PLUGIN}+1))}"
      while read -d ':' PP2; do
        IFS='=' read K V <<< "$PP2"
        if [ "$K" == "$PARAMETER" ]; then
          p_debug "found param $K with value $V"
          echo "$V"
        fi
      done <<< "${PARAMS}:"
    fi
  done <<< "${PLUGINS_ACTIVATED},"
  return 1
}

function PLUGIN_00_link() {
  # If the path is a link to other path, we will create the link and analyze the real path
  local L_PATH="$1"

  if [ -h "$L_PATH" ]; then
    local L_DST="$ROOTFS/$(dirname "$L_PATH")"
    local R_PATH="$(readlink -f "$L_PATH")"
    local R_DST="$ROOTFS/$(dirname "$R_PATH")"
    mkdir -p "$L_DST"

    if [ ! -e "$L_DST/$(basename $L_PATH)" ]; then
      local REL_PATH="$(relPath "$L_DST" "$R_DST")"
      p_debug "$L_PATH is a link to $REL_PATH/$(basename $R_PATH)"
      ln -s $REL_PATH/$(basename $R_PATH) $L_DST/$(basename $L_PATH)
    fi

    add_command "$R_PATH"
    return 1
  fi
}

function PLUGIN_01_which() {
  # This plugin tries to guess whether the command to analize is in the path or not.
  # If the command can be obtained calling which, we'll analyze the actual command and not the short name.
  local S_PATH="$1"
  local W_PATH="$(which $S_PATH)"

  if [ "$W_PATH" != "" -a "$W_PATH" != "$S_PATH" ]; then
    p_debug "$1 is $W_PATH"
    add_command "$W_PATH"
    return 1
  fi
}

function PLUGIN_02_folder() {
  # If it is a folder, just copy it to its location in the new FS
  local S_PATH="$1"

  if [ -d "$S_PATH" ]; then
    p_debug "copying the whole folder $S_PATH"
    copy "$S_PATH"
    return 1
  fi

  return 0
}

function PLUGIN_09_ldd() {
  # Checks the list of dynamic libraries using ldd and copy them to the proper folder
  local S_PATH="$1"
  local LIBS= LIB=
  local COMMAND="$(which -- $S_PATH)"
  local LIB_DIR=
  if [ "$COMMAND" == "" ]; then
    COMMAND="$S_PATH"
  fi

  COMMAND="$(readlink -e $COMMAND)"
  if [ "$COMMAND" == "" ]; then
    p_debug "cannot analize $S_PATH using ldd"
    return 0
  fi

  p_info "inspect command $COMMAND"
  ldd "$COMMAND" > /dev/null 2> /dev/null
  if [ $? -eq 0 ]; then
    LIBS="$(ldd "$COMMAND" | grep -v 'linux-vdso' | grep -v 'statically' | sed 's/^[ \t]*//g' | sed 's/^.* => //g' | sed 's/(.*)//' | sed '/^[ ]*$/d')"
    for LIB in $LIBS; do
      # Here we build the ld config file to add the new paths where the libraries are located
      if [ "$LDCONFIGFILE" != "" ]; then
        LIB_DIR="$(dirname "$LIB")"
        mkdir -p "$ROOTFS/$(dirname $LDCONFIGFILE)"
        echo "$LIB_DIR" >> "$ROOTFS/$LDCONFIGFILE"
      fi
      add_command "$LIB"
    done
  fi

  copy "$COMMAND"
}

function add_command() {
  local CMDTOADD="$1"
  local n=0
  local ALREADY_EXISTS=false
  while [ $n -lt ${#COMMANDS_TO_ADD[@]} ]; do
    if [ "$CMDTOADD" == "${COMMANDS_TO_ADD[$n]}" ]; then
      ALREADY_EXISTS=true
      break
    fi
    n=$((n+1))
  done
  if [ "$ALREADY_EXISTS" == "false" ]; then
    p_debug "need to analyze $CMDTOADD"
    COMMANDS_TO_ADD+=( "$CMDTOADD" )
  fi
}

function arrayze_cmd() {
  # This function creates an array of parameters from a commandline. The special
  # function of this function is that sometimes parameters are between quotes and the
  # common space-separation is not valid. This funcion solves the problem of quotes and
  # then a commandline can be invoked as "${ARRAY[@]}"
  local AN="$1"
  local _CMD="$2"
  local R n=0
  declare -g -n $AN
  while read R; do
    read ${AN}[n] <<< "$R"
    n=$((n+1))
  done < <(printf "%s\n" "$_CMD" | xargs -n 1 printf "%s\n")
}

function analyze_strace_strings() {
  local STRINGS="$1"
  local S
  while read S; do
    S="${S:1:-1}"
    if [ "$S" != "" -a "${S::1}" != "-" ]; then
      S="$(readlink -e -- ${S})"
      if [ "$S" != "" -a -e "$S" -a ! -d "$S" -a -f "$S" ]; then
        p_debug "file $S was used"
        echo "$S"
      fi
    fi
  done <<< "$STRINGS"
}

function PLUGIN_10_strace() {
  # Execute the app without any parameter, using strace and see which files does it open 
  local SECONDSSIM=$(plugin_parameter "strace" "seconds")
  if [[ ! $SECONDSSIM =~ ^[0-9]*$ ]]; then
    SECONDSSIM=3
  fi
  if [ "$SECONDSSIM" == "" ]; then
    SECONDSSIM=3
  fi

  # A file that contains examples of calls for the commands to be considered (e.g. this is because
  # some commands will not perform any operation if they do not have parameters; e.g. echo)
  local EXECFILE=$(plugin_parameter "strace" "execfile")

  local S_PATH="$1"
  local COMMAND="$(which -- $S_PATH)"
  if [ "$COMMAND" == "" ]; then
    p_debug "cannot analize $S_PATH using strace"
    return 0
  fi

  p_info "analysing command $COMMAND using strace and $SECONDSSIM seconds"

  # Let's see if there is a specific commandline (with parameters) for this command in the file
  local CMDTOEXEC CMDLINE
  if [ -e "$EXECFILE" ]; then
    local L 
    while read L; do
      CMDTOEXEC=
      arrayze_cmd CMDLINE "$L"
      n=0
      while [ $n -lt ${#CMDLINE[@]} ]; do
        if [ "${CMDLINE[$n]}" == "$COMMAND" ]; then
          CMDTOEXEC="$L"
          break
        fi
        n=$((n+1))
      done
      if [ "$CMDTOEXEC" != "" ]; then
        break
      fi
    done < "$EXECFILE"
  fi

  COMMAND=($COMMAND)

  # If there is a specific commandline, we'll use it; otherwise we'll run the command as-is
  if [ "$CMDTOEXEC" != "" ]; then
    p_debug "will run $CMDTOEXEC"
    COMMAND=( ${CMDLINE[@]} )
  fi

  local TMPFILE=$(tempfile)
  {
    timeout -s 9 $SECONDSSIM strace -qq -e file -fF -o "$TMPFILE" "${COMMAND[@]}" > /dev/null 2> /dev/null
  } > /dev/null 2> /dev/null

  # Now we'll inspect the files that the execution has used
  local FUNCTIONS
  local STRINGS
  local L BN

  FUNCTIONS="open"
  STRINGS="$(cat "$TMPFILE" | grep -E "($FUNCTIONS)\(" | grep -o '"[^"]*"' | sort -u)"  
  while read L; do
    if [ "$L" != "" ]; then
      BN="$(basename $L)"
      if [ "${BN::3}" == "lib" -o "${BN: -3}" == ".so" ]; then
        add_command "$L"
      else
        copy "$L"
      fi
    fi
  done <<< "$(analyze_strace_strings "$STRINGS")"

  FUNCTIONS="exec.*"
  STRINGS="$(cat "$TMPFILE" | grep -E "($FUNCTIONS)\(" | grep -o '"[^"]*"' | sort -u)"  
  while read L; do
    [ "$L" != "" ] && add_command "$L"
  done <<< "$(analyze_strace_strings "$STRINGS")"

  rm "$TMPFILE"

  copy "$COMMAND"
}

function PLUGIN_11_scripts() {
  # Checks the output of the invocation to the "file" command and guess whether it is a interpreted script or not
  #  If it is, adds the interpreter to the list of commands to add to the container
  p_debug "trying to guess if $1 is a interpreted script"

  local S_PATH="$(which $1)"
  local ADD_PATHS=

  if [ "$S_PATH" == "" -o ! -x "$S_PATH" ]; then
    p_debug "$1 cannot be executed (if it should, please check the path)"
    return 0
  fi

  local FILE_RES="$(file $S_PATH | grep -o ':.* script')"
  if [ "$FILE_RES" == "" ]; then
    p_debug "$S_PATH is not recognised as a executable script"
    return 0
  fi

  FILE_RES="${FILE_RES:2:-7}"
  FILE_RES="${FILE_RES,,}"
  local SHELL_EXEC=
  local SHBANG_LINE=$(cat $S_PATH | sed '/^#!.*/q' | tail -n 1 | sed 's/^#![ ]*//')
  local INTERPRETER="${SHBANG_LINE%% *}"
  ADD_PATHS="$INTERPRETER"
  if [ "$(basename $INTERPRETER)" == "env" ]; then
    ADD_PATHS="$INTERPRETER"
    INTERPRETER="${SHBANG_LINE#* }" # This is in case there are parameters for the interpreter e.g. #!/usr/bin/env bash -c
    INTERPRETER="${INTERPRETER%% *}"
    local W_INTERPRETER="$(which "$INTERPRETER")"
    if [ "$W_INTERPRETER" != "" ]; then
      INTERPRETER="$W_INTERPRETER"
    fi
    ADD_PATHS="${ADD_PATHS}
$INTERPRETER
"
  fi

  case "$(basename "$INTERPRETER")" in
    perl) ADD_PATHS="${ADD_PATHS}
$(perl -e "print qq(@INC)" | tr ' ' '\n' | grep -v -e '^/home' -e '^\.')";;
    python) ADD_PATHS="${ADD_PATHS}
$(python -c 'import sys;print "\n".join(sys.path)' | grep -v -e '^/home' -e '^\.')";;
    bash) ;;
    python) ;;
    *)    p_warning "interpreter $INTERPRETER not recognised"
          return 0;;
  esac

  if [ "$ADD_PATHS" != "" ]; then
    p_debug "found that $S_PATH needs $ADD_PATHS"
    local P
    while read P; do
      [ "$P" != "" ] && add_command "$P"
    done <<< "$ADD_PATHS"
  fi
  return 0
}

function PLUGIN_funcs() {
  # Gets the list of plugins available for the app (those functions named PLUGIN_xxx_<plugin name>)
  echo "$(typeset -F | grep PLUGIN_ | awk '{print $3}' | grep -v 'PLUGIN_funcs')"
}

function plugin_list() {
  local P
  while read P; do
    echo -n "${P##*_},"
  done <<< "$(PLUGIN_funcs)"
  echo
}

# Now we are activating the basic plugins
EXCLUDED_PATHS=()
PLUGINS_ACTIVATED=link,which,folder,ldd,scripts
COMMANDS_TO_ADD=()
FORCEFOLDER=false
ROOTFS=
n=0
while [ $# -gt 0 ]; do
    if [ "${1:0:1}" == "-" -a "${1:1:1}" != "-" -a "${1:1:1}" != "" ]; then
        for f in $(echo "${1:1}" | sed 's/\(.\)/-\1 /g' ); do
            ARR[$n]="$f"
            n=$(($n+1))
        done
    else
        ARR[$n]="$1"
        n=$(($n+1))
    fi
    shift
done

n=0
while [ $n -lt ${#ARR[@]} ]; do
    PARAM="${ARR[$n]}"
    case "$PARAM" in
        --plugin-all)           PLUGINS_ACTIVATED="$(plugin_list),${PLUGINS_ACTIVATED}";;
        --plugin=*)             PLUGINS_ACTIVATED="${PLUGINS_ACTIVATED},${PARAM:9}";;
        --exclude|-e)           n=$(($n+1))
                                EXCLUDED_PATHS+=("${ARR[$n]}");;
        --logfile|-g)           n=$(($n+1))
                                LOGFILE="${ARR[$n]}";;
        --quiet|-q)             QUIET=true;;
        --tarfile|-t)           n=$(($n+1))
                                TARFILE="${ARR[$n]}";;
        --ldconfig|-l)          LDCONFIGFILE=/etc/ld.so.conf;;
        --verbose|-v)           VERBOSE=true;;
        --debug)                DEBUG=true;;
        --force|-f)             FORCEFOLDER=true;;
        --rootfs|-r)            n=$(($n+1))
                                ROOTFS="${ARR[$n]}"
                                if [ ! -d "$(dirname $ROOTFS)" ]; then
                                  finalize 1 "invalid folder (parent folder must exist)"
                                fi;;
        --help | -h)            usage && finalize;;
        --|*)                   [ "$PARAM" == "--" ] && n=$(($n+1))
                                while [ $n -lt ${#ARR[@]} ]; do
                                  PARAM="${ARR[$n]}"
                                  COMMANDS_TO_ADD+=("$PARAM")
                                  n=$(($n+1))
                                done;;
    esac
    n=$(($n+1))
done

[ "$QUIET" == "true" ] && DEBUG= VERBOSE=

if [ "$TARFILE" != "" -a "$ROOTFS" == "" ]; then
  ROOTFS=$(tempdir)
  FORCEFOLDER=true
fi

[ "$ROOTFS" == "" ] && finalize 1 "you must provide a folder (--rootfs) to create the root filesystem or request a tar file (--tarfile)"

ROOTFS="$(readlink -f "$ROOTFS")"
[ "$ROOTFS" == "" ] && finalize 1 "invalid folder to create the root filesystem (the parent folder MUST exist)"

DANGER_FOLDERS="/ /etc /var /sys /proc"
for F in $DANGER_FOLDERS; do
  [ "$ROOTFS" == "$F" ] && finalize "refusing to build root filesystem in folder $ROOTFS"
done
  
[ -e "$ROOTFS" -a ! -d "$ROOTFS" ] && finalize 1 "$ROOTFS exists but it is not a folder"

if [ "$FORCEFOLDER" != "true" -a -d "$ROOTFS" ]; then
  read -p "folder for root filesystem ($ROOTFS) already exists. Are you sure to use it? (y/N) " CONFIRM
  if [ "${CONFIRM^^}" != "Y" ]; then
    finalize 1 "aborting"
  fi
fi

# Check dependencies first
verify_dependencies

p_debug "creating $ROOTFS"
mkdir -p "$ROOTFS"
mkdir -p "$ROOTFS/tmp"
mkdir -p "$ROOTFS/dev"
mkdir -p "$ROOTFS/proc"

i_current=0
while [ $i_current -lt ${#COMMANDS_TO_ADD[@]} ]; do
  CURRENT_CMD="${COMMANDS_TO_ADD[$i_current]}"
  for p in $(PLUGIN_funcs); do
    if is_plugin_active "${p##*_}"; then
      p_debug "invoking plugin ${p##*_}"
      _C_PLUGIN="${p##*_}"
      set_logger "${_C_PLUGIN^^}"
      if ! $p "$CURRENT_CMD"; then
        break
      fi 
      set_logger
    fi
  done
  set_logger
  i_current=$(($i_current+1))
done

if [ "$LDCONFIGFILE" != "" -a -e "$ROOTFS/$LDCONFIGFILE" ]; then
  p_debug "creating ldconfig"
  TMPFILE=$(tempfile)
  awk '!a[$0]++' "$ROOTFS/$LDCONFIGFILE" > "$TMPFILE"
  mv "$TMPFILE" "$ROOTFS/$LDCONFIGFILE"
  ldconfig -r "$ROOTFS"
  p_out "ldconfig recreated"
fi

if [ "$TARFILE" != "" ]; then
  if [ "$TARFILE" != "-" ]; then
    p_info "producing tar file $TARFILE"
    tar cf "$TARFILE" -C "$ROOTFS" .
  else
    tar c -C "$ROOTFS" .
  fi
fi