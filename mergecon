#!/bin/bash
#
# mergecon - Merge container file systems
# https://github.com/grycap/minicon
#
# Copyright (C) GRyCAP - I3M - UPV 
# Developed by Carlos A. caralla@upv.es
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

function usage() {
  cat <<EOF
mergecon is a tool that merges the filesystems of two different container images. It creates
  a new container image that is built from the combination of the layers of the filesystems of
  the input containers.

$0 <options>
  --first | -1 <image>      name of the first container image (will use docker save to dump it)
  --second | -2 <image>     name of the second container image (will use docker save to dump it)
                            the default behaviour gives more priority to the second image. I.e. in
                            case of overlapping files in both input images, the files in the second
                            image will be exposed to the final image.
  --name | -n <name>        name of the resulting container image. If not provided, the resulting
                            name will be the concatenation of the names of the two input images:
                            <image1>:<image2> (the : in the input image names is removed).
  --working | -w <folder>   working folder. If not provided will create a temporary folder in /tmp
  --list | -l               lists the layers in the images (useful for filesystem composition)
  --file | -f <file>        tar file where the resulting image will be created. If not provided,
                            the image will be loaded into docker.
  --keeptemporary | -k      Keeps the temporary folder. Otherwise, the folder is removed (if it is
                            created by mergecon).
  --verbose | -v            Shows more information about the procedure.
  --debug                   Shows a lot more information about the procedure.
  --help | -h               Shows this help and exits.
EOF
}

_MUTED_EXPRESSIONS=()

function p_mute() {
  _MUTED_EXPRESSIONS+=("${1// /[[:space:]]}")
}

function p_errfile() {
  local i
  local E
  for ((i=0;i<${#_MUTED_EXPRESSIONS[@]};i=i+1)); do
    E="${_MUTED_EXPRESSIONS[$i]}"
    if [[ "$1" =~ ^$E ]]; then
      return 0
    fi
  done

  if [ "$LOGFILE" == "" ]; then
    echo "$@" >&2
  else
    touch -f "$LOGFILE"
    if [ $? -eq 0 ]; then
      echo "$@" >> "$LOGFILE"
    fi
  fi
}

function p_error() {
  local O_STR="[ERROR] $LOGGER $(date +%Y.%m.%d-%X) $@"
  p_errfile "$O_STR"
}

function p_warning() {
  local O_STR="[WARNING] $LOGGER $(date +%Y.%m.%d-%X) $@"
  p_errfile "$O_STR"
}

function p_info() {
  local L
  if [ "$VERBOSE" == "true" ]; then
    local TS="$(date +%Y.%m.%d-%X)"
    while read L; do
      p_errfile "[INFO] $LOGGER $TS $@"
    done <<< "$@"
  fi
}

function p_out() {
  if [ "$QUIET" != "true" ]; then
    while read L; do
      echo "$@"
    done <<< "$@"
  fi
}

function p_debug() {
  local L
  if [ "$DEBUG" == "true" ]; then
    local TS="$(date +%Y.%m.%d-%X)"
    while read L; do
      p_errfile "[DEBUG] $LOGGER $TS $L"
    done <<< "$@"
  fi
}

function set_logger() {
  if [ "$1" != "" ]; then
    LOGGER="[$1]"
  else
    LOGGER=
  fi
}

function finalize() {
  # Finalizes the execution of the this script and shows an error (if provided)
  local ERR=$1
  shift
  local COMMENT=$@
  [ "$ERR" == "" ] && ERR=0
  [ "$COMMENT" != "" ] && p_error "$COMMENT"
  if [ "$KEEPTEMPORARY" != "true" ]; then
    p_debug removing temporary folder "$TMPDIR"
    rm -rf "$TMPDIR"
  fi  
  exit $ERR
}
function tempfile {
  local FOLDER="$1"
  if [ "$FOLDER" == "" ]; then
    FOLDER=/tmp
  fi
  if [ ! -d "$FOLDER" ]; then
    finalize 1 "folder $FOLDER does not exist"
  fi
  RES=$FOLDER/ftemp_${RANDOM}_$(date +%s)
  touch $RES
  while [ $? -ne 0 ]; do
    RES=$FOLDER/ftemp_${RANDOM}_$(date +%s)
    touch $RES
  done
  echo $RES
}

function tempdir() {
  # Creates a unique temporary folder
  local FOLDER="$1"
  if [ "$FOLDER" == "" ]; then
    FOLDER=/tmp
  fi
  if [ ! -d "$FOLDER" ]; then
    finalize 1 "folder $FOLDER does not exist"
  fi
  RES=$FOLDER/ftemp_${RANDOM}_$(date +%s)
  mkdir -p $RES 2> /dev/null
  while [ $? -ne 0 ]; do
    RES=$FOLDER/ftemp_${RANDOM}_$(date +%s)
    mkdir -p $RES 2> /dev/null
  done
  echo $RES
}

function verify_dependencies() {
  if ! docker --version > /dev/null 2> /dev/null; then
    finalize 1 "docker command is needed"
  fi
  if ! jq --version > /dev/null 2> /dev/null; then
    finalize 1 "jq command is needed"
  fi
  if ! tar --version > /dev/null 2> /dev/null; then
    finalize 1 "tar command is needed"
  fi
}

function read_lines_in_array() {
  local MANIFEST="$1"
  local VARNAME="$2"

  local R n=0
  declare -g -a -n $VARNAME
  while read R; do
    read ${VARNAME}[$n] <<< "$R"
    n=$((n+1))
  done <<<"$(echo "$MANIFEST" | jq -r '.[] | .Layers | .[]')"
}

function join() {
  local CHAR="$1"
  shift

  local n=0
  while [ $# -gt 0 ]; do
    if [ "$n" != "0" ]; then
      echo -n "$CHAR"
    fi
    echo -n "$1"
    n=$((n+1))
    shift
  done
  echo
}

function extract_image() {
  local FOLDER="$1"
  local IMAGENAME="$2"

  if [ "$IMAGENAME" != "" ]; then
    mkdir -p "$FOLDER"
    local T="$(tempfile '.')"
    if ! docker save "$IMAGENAME" -o "$T" 2> /dev/null; then
      finalize 1 "could not retrieve image $IMAGENAME"
    fi
    tar xf "$T" -C "$FOLDER"
    rm -f "$T"
  fi
}

n=0
while [ $# -gt 0 ]; do
    if [ "${1:0:1}" == "-" -a "${1:1:1}" != "-" -a "${1:1:1}" != "" ]; then
        for f in $(echo "${1:1}" | sed 's/\(.\)/-\1 /g' ); do
            ARR[$n]="$f"
            n=$(($n+1))
        done
    else
        ARR[$n]="$1"
        n=$(($n+1))
    fi
    shift
done

TMPDIR=
OUTFILE=
n=0
while [ $n -lt ${#ARR[@]} ]; do
    PARAM="${ARR[$n]}"
    case "$PARAM" in
        --file|-f)              n=$(($n+1))
                                OUTFILE="${ARR[$n]}";;
        --continue|-c)          CONTINUE=true;;
        --working|-w)           n=$(($n+1))
                                TMPDIR="${ARR[$n]}";;
        --name|-n)              n=$(($n+1))
                                MERGEDNAME="${ARR[$n]}";;
        --first|-1)             n=$(($n+1))
                                FIRSTIMAGE="${ARR[$n]}";;
        --second|-2)            n=$(($n+1))
                                SECONDIMAGE="${ARR[$n]}";;
        --list|-l)              LISTLAYERS=true;;
        --verbose|-v)           VERBOSE=true;;
        --debug)                DEBUG=true;;
        --help | -h)            usage && finalize;;
        --keeptemporary|-k)     KEEPTEMPORARY="true";;
        *)                      usage && finalize 1;;
    esac
    n=$(($n+1))
done

verify_dependencies

if [ "$OUTFILE" != "" ]; then
  OUTFILE="$(readlink -m "$OUTFILE")"
fi

if [ "$TMPDIR" == "" ]; then
  TMPDIR="$(tempdir)"
else
  # To avoid removing the folder in case that is is provided in the commandline
  KEEPTEMPORARY=false
fi

if [ "$MERGEDNAME" == "" ]; then
  MERGEDNAME="$(cat /proc/sys/kernel/random/uuid)"
  MERGEDNAME="${MERGEDNAME%%-*}"
fi

# Correct MERGEDNAME
IFS=':' read BASE TAG <<< "${MERGEDNAME}"
if [ "$TAG" == "" ]; then
  MERGEDNAME="${MERGEDNAME}:latest"
fi
p_out "$MERGEDNAME"

cd $TMPDIR 2> /dev/null || finalize 1 "could not change to folder $TMPDIR"
p_info "working folder: $TMPDIR"

if [ "$CONTINUE" != "true" ]; then
  extract_image "1" "$FIRSTIMAGE"
  extract_image "2" "$SECONDIMAGE"
fi

MANIFEST_1="$(cat 1/manifest.json 2> /dev/null)"
read_lines_in_array "$MANIFEST_1" "LAYERS_1"
MANIFEST_2="$(cat 2/manifest.json 2> /dev/null)"
read_lines_in_array "$MANIFEST_2" "LAYERS_2"

if [ "$LISTLAYERS" == "true" ]; then
  if [ "$FIRSTIMAGE" != "" ]; then
    for ((n=0;n<${#LAYERS_1[@]};n++)); do
      p_out $n ${LAYERS_1[$n]}
    done
  fi
  if [ "$SECONDIMAGE" != "" ]; then
    for ((n=0;n<${#LAYERS_2[@]};n++)); do
      p_out $n ${LAYERS_2[$n]}
    done
  fi
  finalize
fi

if [ "$FIRSTIMAGE" == "" ]; then
  p_warning "missing starting image"
fi

if [ "$SECONDIMAGE" == "" ]; then
  p_warning "missing image to merge"
fi

if [ "$MANIFEST_1" == ""  -a "$MANIFEST_2" == "" ]; then
  finalize 1 "missing manifests"
fi

p_debug "layers for image $FIRSTIMAGE: ${LAYERS_1[@]}"
p_debug "layers for image $SECONDIMAGE: ${LAYERS_2[@]}"

IMGID="$(cat /proc/sys/kernel/random/uuid | sha256sum)"
IMGID="${IMGID%% *}"

p_info "adding new layers"
for ((n=0;n<${#LAYERS_2[@]};n++)); do
  LAYERFOLDER="$(dirname ${LAYERS_2[$n]})"
  p_debug "copying folder 2/$LAYERFOLDER to 1/$LAYERFOLDER"
  cp -r 2/$LAYERFOLDER 1/
done

p_info "updating manifest"
NLAYERS_S="\"$(join "\",\"" "${LAYERS_2[@]}")\""
echo "$MANIFEST_1" | jq "[ .[] | .Layers += [ $NLAYERS_S ] | .RepoTags = [ \"$MERGEDNAME\" ] ]  " > 1/manifest.json

CONFIGFILE_1="1/$(echo "$MANIFEST_1" | jq -r ".[] | .Config")"
CONFIGCONTENT_1="$(cat $CONFIGFILE_1)"
CONFIGFILE_2="2/$(echo "$MANIFEST_2" | jq -r ".[] | .Config")"
CONFIGCONTENT_2="$(cat $CONFIGFILE_2)"

DIFFIDS="$(echo "$CONFIGCONTENT_2" | jq ".rootfs.diff_ids")"
echo "$CONFIGCONTENT_1" | jq "del(.history)|del(.container_config)|del(.container)|.config.Image=\"sha256:$IMGID\"|.created=(now|todate)|.rootfs.diff_ids+=$DIFFIDS" > "${CONFIGFILE_1}"

rm 1/repositories

if [ "$OUTFILE" != "" ]; then
  p_debug "outputting image to file $OUTFILE"
  tar cf "$OUTFILE" -C 1 .
else
  p_debug "loading new image in docker"
  docker load < <(tar c -C 1 .)
fi

finalize