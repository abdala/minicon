#!/bin/bash
#
# importcon - Imports a filesystem to a container (copying the features from other container)
# https://github.com/grycap/minicon
#
# Copyright (C) GRyCAP - I3M - UPV 
# Developed by Carlos A. caralla@upv.es
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

BASEFOLDER=$(dirname $0)
MINICON="$(which minicon)"
if [ "$MINICON" == "" ]; then
  MINICON="$BASEFOLDER/minicon"
fi

IMPORTCON="$(which importcon)"
if [ "$IMPORTCON" == "" ]; then
  IMPORTCON="$BASEFOLDER/importcon"
fi

MERGECON="$(which mergecon)"
if [ "$MERGECON" == "" ]; then
  MERGECON="$BASEFOLDER/mergecon"
fi

function usage() {
  cat <<EOF

minidock is a tool that gets one docker container and inspects it to create a new container whose size
  has been minimized by stripping all the files that are not needed to run it.

$0 <options> <options for minicon> [ --docker-opts <options for docker> ] -- <run for the container> 

  <run for the container>   Is the whole commandline to be analised in the run. These are the same parameters
                            that you would pass to "docker run ... <image> <run for the container>". 
                            If no run is provided, minidock will use the default command. And if the image
                            as no default command, it will try to use one of the -R or -E commands.
                            * the aim is that you run "minidock" as if you used a "docker run" for your container.
  <options for docker>      If you need them, you can include some options that will be raw-passed to the
                            docker run command used during the analysis. (i.e. minidock will execute
                            docker run <options generated> <options for docker> ...).
  <options for minicon>     If you need to, you can add some minicon-specific options. The supported options
                            are --include --exclude --plugin
  --image | -i <image>      Name of the existing image to minimize
  --tag | -t <tag>          Tag for the resulting image (random if not provided)
  --default-cmd | -d        Analyze the default command for the containers in the original image
  --apt                     Install the dependencies from minicon using apt-get commands (in the container
                            used for the simulation).
  --yum                     Install the dependencies from minicon using yum commands (in the container used
                            for the simulation).
  --execution | -E <full commandline execution>
                            Commandline to analyze when minimizing the container (i.e. that commandline should
                            be able to be executed in the resulting container so the files, libraries, etc. needed
                            should be included). The difference with -R parameter is that in this case, the 
                            Entrypoint is not prepended to the commandline (docker exec vs docker run).
  --run | -R <full commandline run>
                            Command to analyze when minimizing the container (i.e. that command should be able
                            to be run in the resulting container so the files, libraries, etc. needed
                            should be included). The difference with -E parameter is that in this case, the 
                            Entrypoint is prepended to the commandline (docker exec vs docker run).
  -2 <image>                If needed, you can merge the resulting minimized image with other. This is very specific
                            for the "mergecon" tool. It is useful for (e.g.) adding a minimal Alpine distro (with
                            ash and so on) to the minimized filesystem.
  --verbose | -v            Shows more information about the procedure.
  --debug                   Shows a lot more information about the procedure.
  --help | -h               Shows this help and exits.

EOF
}

function verify_dependencies() {
  if [ ! -x "$MINICON" ]; then
    finalize 1 "cannot find minicon"
  fi
  if [ ! -x "$IMPORTCON" ]; then
    finalize 1 "cannot find importcon"
  fi
  if [ ! -x "$MERGECON" ]; then
    finalize 1 "cannot find mergecon"
  fi
  if ! docker --version > /dev/null 2> /dev/null; then
    finalize 1 "docker command is needed to import the image"
  fi
  if ! jq --version > /dev/null 2> /dev/null; then
    finalize 1 "jq command is needed"
  fi
}

_MUTED_EXPRESSIONS=()

function p_mute() {
  _MUTED_EXPRESSIONS+=("${1// /[[:space:]]}")
}

function p_errfile() {
  local i
  local E
  for ((i=0;i<${#_MUTED_EXPRESSIONS[@]};i=i+1)); do
    E="${_MUTED_EXPRESSIONS[$i]}"
    if [[ "$1" =~ ^$E ]]; then
      return 0
    fi
  done

  if [ "$LOGFILE" == "" ]; then
    echo "$@" >&2
  else
    touch -f "$LOGFILE"
    if [ $? -eq 0 ]; then
      echo "$@" >> "$LOGFILE"
    fi
  fi
}

function p_error() {
  local O_STR="[ERROR] $LOGGER $(date +%Y.%m.%d-%X) $@"
  p_errfile "$O_STR"
}

function p_warning() {
  local O_STR="[WARNING] $LOGGER $(date +%Y.%m.%d-%X) $@"
  p_errfile "$O_STR"
}

function p_info() {
  local L
  if [ "$VERBOSE" == "true" ]; then
    local TS="$(date +%Y.%m.%d-%X)"
    while read L; do
      p_errfile "[INFO] $LOGGER $TS $@"
    done <<< "$@"
  fi
}

function p_out() {
  if [ "$QUIET" != "true" ]; then
    while read L; do
      echo "$@"
    done <<< "$@"
  fi
}

function p_debug() {
  local L
  if [ "$DEBUG" == "true" ]; then
    local TS="$(date +%Y.%m.%d-%X)"
    while read L; do
      p_errfile "[DEBUG] $LOGGER $TS $L"
    done <<< "$@"
  fi
}

function set_logger() {
  if [ "$1" != "" ]; then
    LOGGER="[$1]"
  else
    LOGGER=
  fi
}

_OLD_LOGGER=

function push_logger() {
  _OLD_LOGGER="$LOGGER"
  LOGGER="$LOGGER[$1]"
}

function pop_logger() {
  LOGGER="$_OLD_LOGGER"
}

function finalize() {
  # Finalizes the execution of the this script and shows an error (if provided)
  local ERR=$1
  shift
  local COMMENT=$@
  [ "$ERR" == "" ] && ERR=0
  [ "$COMMENT" != "" ] && p_error "$COMMENT"
  if [ "$KEEPTEMPORARY" != "true" ]; then
    p_debug removing temporary folder "$TMPDIR"
    rm -rf "$TMPDIR"
  fi  
  exit $ERR
}
function tempfile {
  local FOLDER="$1"
  if [ "$FOLDER" == "" ]; then
    FOLDER=/tmp
  fi
  if [ ! -d "$FOLDER" ]; then
    finalize 1 "folder $FOLDER does not exist"
  fi
  RES=$FOLDER/ftemp_${RANDOM}_$(date +%s)
  touch $RES
  while [ $? -ne 0 ]; do
    RES=$FOLDER/ftemp_${RANDOM}_$(date +%s)
    touch $RES
  done
  echo $RES
}

function tempdir() {
  # Creates a unique temporary folder
  local FOLDER="$1"
  if [ "$FOLDER" == "" ]; then
    FOLDER=/tmp
  fi
  if [ ! -d "$FOLDER" ]; then
    finalize 1 "folder $FOLDER does not exist"
  fi
  RES=$FOLDER/ftemp_${RANDOM}_$(date +%s)
  mkdir -p $RES 2> /dev/null
  while [ $? -ne 0 ]; do
    RES=$FOLDER/ftemp_${RANDOM}_$(date +%s)
    mkdir -p $RES 2> /dev/null
  done
  echo $RES
}
function trim() {
  shopt -s extglob
  local A="${1##+([[:space:]])}"
  A="${A%%+([[:space:]])}"
  shopt -u extglob
  echo "$A"
}

function build_cmdline() {
  local SHCMDLINE=""
  while [ $# -gt 0 ]; do
    if [ "$1" == "&&" -o "$1" == ">" -o "$1" == ">>" -o "$1" == "2>" -o "$1" == "2>>" -o "$1" == "<" -o "$1" == "<<" ]; then
      SHCMDLINE="${SHCMDLINE} $1"
    else
      SHCMDLINE="${SHCMDLINE} \"$1\""
    fi
    shift
  done
  echo "$SHCMDLINE"
}

function arrayze_cmd() {
  # This function creates an array of parameters from a commandline. The special
  # function of this function is that sometimes parameters are between quotes and the
  # common space-separation is not valid. This funcion solves the problem of quotes and
  # then a commandline can be invoked as "${ARRAY[@]}"
  local AN="$1"
  local _CMD="$2"
  local R n=0
  while read R; do
    read ${AN}[n] <<< "$R"
    n=$((n+1))
  done < <(printf "%s\n" "$_CMD" | xargs -n 1 printf "%s\n")
}
function generate_dockerimagename() {
  local NEWNAME
  NEWNAME="$(cat /proc/sys/kernel/random/uuid)"
  NEWNAME="${NEWNAME%%-*}"
  echo "$NEWNAME"
}

function correct_dockerimagename() {
  local IMNAME="$1"
  local BASE TAG

  # Correct NEWNAME
  IFS=':' read BASE TAG <<< "${IMNAME}"
  if [ "$TAG" == "" ]; then
    IMNAME="${IMNAME}:latest"
  fi
  echo "$IMNAME"
}

_INSPECT_STRING=
_INSPECT_IMAGE=
function get_config_field() {
  local IMAGE="$1"
  local FIELD="$2"
  local RAW_JQ="$3"
  local C_RESULT

  if [ "$_INSPECT_IMAGE" != "$IMAGE" ]; then
    _INSPECT_STRING="$(docker inspect $IMAGE)"
    _INSPECT_IMAGE="$IMAGE"
  fi

  C_RESULT="$(echo "$_INSPECT_STRING" | jq -r "if .[].Config.${FIELD} != null then if .[].Config.${FIELD}${RAW_JQ} | type == \"array\" then .[].Config.${FIELD}${RAW_JQ} | .[] else .[].Config.${FIELD}${RAW_JQ} end else null end")"
  echo "$(trim "$C_RESULT")"
}

function get_config_field_raw() {
  local IMAGE="$1"
  local FIELD="$2"
  local RAW_JQ="$3"
  local C_RESULT

  if [ "$_INSPECT_IMAGE" != "$IMAGE" ]; then
    _INSPECT_STRING="$(docker inspect $IMAGE)"
    _INSPECT_IMAGE="$IMAGE"
  fi

  C_RESULT="$(echo "$_INSPECT_STRING" | jq -r "if .[].Config.${FIELD} != null then .[].Config.${FIELD}${RAW_JQ} else null end")"
  echo "$(trim "$C_RESULT")"
}


n=0
while [ $# -gt 0 ]; do
    if [ "${1:0:1}" == "-" -a "${1:1:1}" != "-" -a "${1:1:1}" != "" ]; then
        for f in $(echo "${1:1}" | sed 's/\(.\)/-\1 /g' ); do
            ARR[$n]="$f"
            n=$(($n+1))
        done
    else
        ARR[$n]="$1"
        n=$(($n+1))
    fi
    shift
done

TMPDIR=
IMPORTCONOPTS=()
MERGECONOPTS=()

# The strace plugin needs the ability of process tracking (or privileged, but we do not want too much permissions)
DOCKEROPTS=("--cap-add" "SYS_PTRACE")

# minidock runs minicon with all the plugins activated
MINICONOPTS=("--plugin-all")

# The main execution: it enables running minicon as if it was docker run ... 
MAINEXEC=()

# Other executions. They need to be captured to add them the entrypoint
SECONDARYEXECS=()

# Run the default command as a secondary execution
EXECUTEDEFAULTCMD=false

n=0
while [ $n -lt ${#ARR[@]} ]; do
    PARAM="${ARR[$n]}"
    case "$PARAM" in
        --default-cmd|-d)       EXECUTEDEFAULTCMD=true;;
        --apt)                  DEPENDENCIES_APT=true;;
        --yum)                  DEPENDENCIES_YUM=true;;
        --plugin=*)             MINICONOPTS+=("$PARAM");;
        --exclude|-e|--include|-I)
                                MINICONOPTS+=("$PARAM")
                                n=$(($n+1))
                                MINICONOPTS+=("${ARR[$n]}");;
        --mode=*)               MINICONOPTS+=("--plugin=strace:mode=${PARAM:7}")
                                ;;
        --mode)                 n=$(($n+1))
                                MINICONOPTS+=("--plugin=strace:mode=${ARR[$n]}")
                                ;;
        --execution|-E)         n=$(($n+1))
                                SECONDARYEXECS+=("-E")
                                SECONDARYEXECS+=("${ARR[$n]}");;
        --run|-R)               n=$(($n+1))
                                SECONDARYEXECS+=("-R")
                                SECONDARYEXECS+=("${ARR[$n]}");;
        --second|-2)            n=$(($n+1))
                                SECONDIMAGE="${ARR[$n]}";;
        --image|-i)             n=$(($n+1))
                                FROMIMAGE="${ARR[$n]}";;
        --tag|-t)               n=$(($n+1))
                                NEWNAME="${ARR[$n]}";;
        --simulate|-s)          SIMULATEONLY=true;;
        --verbose|-v)           MINICONOPTS+=("--verbose")
                                IMPORTCONOPTS+=("--verbose")
                                MERGECONOPTS+=("--verbose")
                                VERBOSE=true;;
        --debug)                MINICONOPTS+=("--debug")
                                IMPORTCONOPTS+=("--debug")
                                MERGECONOPTS+=("--debug")
                                DEBUG=true;;
        --help | -h)            usage && finalize;;
        --keeptemporary|-k)     KEEPTEMPORARY="true";;
        --docker-opts)          n=$(($n+1))
                                while [ $n -lt ${#ARR[@]} -a "${ARR[$n]}" != "--" ]; do
                                  DOCKEROPTS+=("${ARR[$n]}")
                                  n=$(($n+1))
                                done
                                if [ "${ARR[$n]}" == "--" ]; then
                                  n=$(($n-1))
                                fi;;
        --)                     n=$(($n+1))
                                while [ $n -lt ${#ARR[@]} ]; do
                                  MAINEXEC+=("${ARR[$n]}")
                                  n=$(($n+1))
                                done;;
        *)                      usage && finalize 1 "invalid parameter $PARAM"
    esac
    n=$(($n+1))
done

verify_dependencies

if [ "$FROMIMAGE" == "" ]; then
  finalize 1 "you have to state the image to minimize (flag -i)"
fi

if [ "$NEWNAME" == "" ]; then
  p_warning "No image provided. A random one will be created (it will be echoed at the end of the procedure)"
fi

# Get the Entrypoint and the default command
CMDLINE_EP=($(get_config_field "$FROMIMAGE" "Entrypoint"))
CMDLINE_CMD=($(get_config_field "$FROMIMAGE" "Cmd"))

if [ "$CMDLINE_EP" == "null" ]; then
  CMDLINE_EP=()
else
  p_debug "found Entrypoint: ${CMDLINE_EP[@]}"
fi

if [ "$CMDLINE_CMD" == "null" ]; then
  CMDLINE_CMD=()
else
  p_debug "found Cmd: ${CMDLINE_CMD[@]}"
fi

TMPDIR=$(tempdir)
REMOTEMINICON="/bin/minicon"
MINICONFOLDER="-v $(readlink -e $MINICON):$REMOTEMINICON"
REMOTEWORKING="/minicon/work"
WORKINGFOLDER="-v $TMPDIR:$REMOTEWORKING"

p_info "minimizing container using minicon"

# Add dependencies (if they are requested)
DEPENDENCIES=
if [ "$DEPENDENCIES_APT" == "true" ]; then
  if [ "$DEBUG" == "true" ]; then
    DEPENDENCIES="$(build_cmdline apt-get -y update \&\& apt-get -y install bash libc-bin tar rsync file strace \&\&)"
  else
    DEPENDENCIES="$(build_cmdline apt-get -y update \> /dev/null 2\> /dev/null \&\& apt-get -y install bash libc-bin tar rsync file strace \> /dev/null 2\> /dev/null \&\&)"
  fi
else
  if [ "$DEPENDENCIES_YUM" == "true" ]; then
    if [ "$DEBUG" == "true" ]; then
      DEPENDENCIES="$(build_cmdline yum install -y bash tar rsync file strace which \&\&)"
    else
      DEPENDENCIES="$(build_cmdline yum install -y bash tar rsync file strace which \> /dev/null 2\> /dev/null \&\&)"
    fi
  fi
fi

if [ "$DEPENDENCIES" == "" ]; then
  p_warning "Dependencies are not installed. Please make sure that the dependencies for the minicon plugins are installed in the image $FROMIMAGE. Otherwise, please use --apt or --yum flags"
fi

# The default behavior is to add the Entrypoint to the MAINEXEC... unless it uses the first -E command
ADDEPTOMAINEXEC=true

# If we do not have a main execution, we'll try to use the default command
if [ "${MAINEXEC}" == "" ]; then
  MAINEXEC=()

  if [ "$CMDLINE_EP" != "" ]; then
    ADDEPTOMAINEXEC=false
    MAINEXEC+=("${CMDLINE_EP[@]}")
  fi

  if [ "$CMDLINE_CMD" != "" ]; then
    MAINEXEC+=("${CMDLINE_CMD[@]}")

    # If we grab the default command as the main execution, discard the main command
    CMDLINE_CMD=()
  fi

  if [ "${MAINEXEC}" != "" ]; then
    p_info "using the default command as the main execution"
  fi  
fi

# If we still do not have a main execution, let's try if the user added additional executions or runs and we'll get the first one as the main one
if [ "${MAINEXEC}" == "" ]; then
  if [ ${#SECONDARYEXECS[@]} -gt 0 ]; then
    arrayze_cmd MAINEXEC "${SECONDARYEXECS[@]:1:1}"
    if [ "${SECONDARYEXECS[0]}" == "-E" ]; then
      ADDEPTOMAINEXEC=false
      p_info "using the first execution as the main execution"
    else
      p_info "using the first run as the main execution"
    fi
    SECONDARYEXECS=("${SECONDARYEXECS[@]:2}")
  fi
fi

# If we have additional executions, add them
if [ ${#SECONDARYEXECS[@]} -gt 0 ]; then
  n=0
  while ((n<${#SECONDARYEXECS[@]})); do
    RUNOREXEC="${SECONDARYEXECS[$n]}"
    n=$((n+1))
    MINICONOPTS+=("-E")
    CUR_EXECUTION=

    # An execution (-E) does not add the entrypoint, while a run (-R) must add it: docker run ... vs docker exec ...
    # TODO: at this moment each run is independent from the other... it means that an application will not be running after
    #       it has been analyzed.
    if [ "$RUNOREXEC" == "-R" ]; then
      if [ "$CMDLINE_EP" != "" ]; then
        CUR_EXECUTION="${CMDLINE_EP[@]} "
      fi
    fi
    CUR_EXECUTION="${CUR_EXECUTION}${SECONDARYEXECS[$n]}"
    MINICONOPTS+=("$CUR_EXECUTION")
    n=$((n+1))
  done
fi

# If the user stated that additionally add the default command, we'll add it
if [ "$EXECUTEDEFAULTCMD" == "true" ]; then
  if [ "$CMDLINE_CMD" != "" ]; then
    MINICONOPTS+=("-E")
    CUR_EXECUTION=()
    if [ "$CMDLINE_EP" != "" ]; then
      CUR_EXECUTION=("${CMDLINE_EP[@]}")
    fi
    CUR_EXECUTION+=("${CMDLINE_CMD[@]}")
    CUR_EXECUTION="${CUR_EXECUTION[@]}"
    MINICONOPTS+=("${CUR_EXECUTION}")
  else
    p_warning "no default execution is additionally run"
  fi
fi

# Now we have to state the main execution (whether stated explicitly, implicitly by not adding a default execution or the first execution)
if [ "$CMDLINE_EP" != "" -a "$ADDEPTOMAINEXEC" == "true" ]; then
  MAINEXEC=("${CMDLINE_EP[@]}" "${MAINEXEC[@]}")
fi

if [ ${#MAINEXEC} -eq 0 ]; then
  finalize 1 "no execution available (neither default execution, main execution or additional execution)"
fi

# Add the main execution
MINICONOPTS+=("--")
MINICONOPTS+=("${MAINEXEC[@]}")

p_debug docker run --rm $MINICONFOLDER $WORKINGFOLDER --entrypoint "" "${DOCKEROPTS[@]}" "$FROMIMAGE" \
  sh -c "${DEPENDENCIES}$(build_cmdline "$REMOTEMINICON" "-t" "$REMOTEWORKING/image.tar" "${MINICONOPTS[@]}")"

if [ "$SIMULATEONLY" == "true" ]; then
  p_warning "not executing because only wanted to simulate"
else
  docker run --rm $MINICONFOLDER $WORKINGFOLDER --entrypoint "" "${DOCKEROPTS[@]}" "$FROMIMAGE" \
    sh -c "${DEPENDENCIES}$(build_cmdline "$REMOTEMINICON" "-t" "$REMOTEWORKING/image.tar" "${MINICONOPTS[@]}")"

  if [ $? -ne 0 ]; then
    finalize 1 "failed to run minicon"
  fi
fi

# Now we import the resulting filesystem into docker (copying the entrypoint, etc.)
IMPORTCONOPTS="${IMPORTCONOPTS[@]}"
p_debug $IMPORTCON $IMPORTCONOPTS -i "$FROMIMAGE" -t "$NEWNAME" -A $TMPDIR/image.tar

if [ "$SIMULATEONLY" == "true" ]; then
  p_warning "not executing because only wanted to simulate"
  if [ "$NEWNAME" == "" ]; then
    NEWNAME="$(generate_dockerimagename)"
  fi
  IMAGENAME="$NEWNAME"
else
  IMAGENAME="$($IMPORTCON $IMPORTCONOPTS -i "$FROMIMAGE" -t "$NEWNAME" -A $TMPDIR/image.tar)"

  if [ $? -ne 0 ]; then
    finalize 1 "failed to run importcon"
  fi
fi

p_info "image $IMAGENAME imported"
p_out "$IMAGENAME"

if [ "$SECONDIMAGE" == "" ]; then
  finalize
fi

# Merge the container (if requested)
p_info "merging with container $SECONDIMAGE using mergecon"
p_debug $MERGECON "${MERGECONOPTS[@]}" -1 "$IMAGENAME" -2 "$SECONDIMAGE" -t "$IMAGENAME"

if [ "$SIMULATEONLY" == "true" ]; then
  p_warning "not executing because only wanted to simulate"
else
  $MERGECON "${MERGECONOPTS[@]}" -1 "$IMAGENAME" -2 "$SECONDIMAGE" -t "$IMAGENAME"

  if [ $? -ne 0 ]; then
    finalize 1 "failed to run mergecon"
  fi
fi

finalize